# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
# define tl s[k].l
# define tr s[k].r
# define mid (l+r>>1)
# define LL long long
using namespace std;
const int MAX=1e5+5;
struct p{
	int x,l,r;
}s[MAX<<5];
struct q{
	int x,id;
	bool operator< (const q &a)
	const{
		return x<a.x;
	}
}A[MAX];
int n,m,id,tot;
LL ans;
int h[MAX],het[MAX],tax[MAX],Log[MAX],rk[MAX],sa[MAX],a[MAX],rt[MAX];
int f[21][MAX];
bool fl;
int read()
{
	int x(0);
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar());
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x;
}
bool cmp(int *a,int x,int y,int w) {return a[x]==a[y]&&a[x+w]==a[y+w];}
void rsort()
{
	for(int i=0;i<=m;++i)
	  tax[i]=0;
	for(int i=1;i<=n;++i)
	  ++tax[rk[h[i]]];
	for(int i=1;i<=m;++i)
	  tax[i]+=tax[i-1];
	for(int i=n;i>=1;--i)
	  sa[tax[rk[h[i]]]--]=h[i];
}
void Suffix()
{
	for(int i=1;i<=n;++i)
	  rk[i]=a[i],h[i]=i;
	m=id+1,rsort();
	for(int p=1,w=1,i;p<n;w+=w,m=p)
	  {
	  	for(p=0,i=n-w+1;i<=n;++i)
	  	  h[++p]=i;
	  	for(i=1;i<=n;++i)
	  	  if(sa[i]>w) h[++p]=sa[i]-w;
	  	rsort(),swap(rk,h),rk[sa[1]]=p=1;
	  	for(i=2;i<=n;++i)
	  	  rk[sa[i]]=cmp(h,sa[i],sa[i-1],w)?p:++p;
	  }
	int j,k=0;
	for(int i=1;i<=n;het[rk[i++]]=k)
	  for(k=k?k-1:k,j=sa[rk[i]-1];a[j+k]==a[i+k];++k);
}
int change(int pre,int l,int r,int x)
{
	int k=++tot;
	s[k]=s[pre],++s[k].x;
	if(l==r) return k;
	if(x<=mid) tl=change(s[pre].l,l,mid,x);
	else tr=change(s[pre].r,mid+1,r,x);
	return k;
}
int ask(int l,int r,int k,int L,int R)
{
	if(fl) return 1;
	if(l>R||L>r) return 0;
	if(l>=L&&r<=R) return fl=s[k].x;
	return ask(l,mid,tl,L,R)+ask(mid+1,r,tr,L,R);
}
int GET_LCP(int l,int r)
{
	if(l==r) return n-sa[l]+1;
	int t=Log[r-l];
	return min(f[t][l+1],f[t][r-(1<<t)+1]);
}
void Init()
{
	Log[0]=-1;
	for(int i=1;i<=n;++i)
	  Log[i]=Log[i>>1]+1,f[0][i]=het[i],rt[i]=change(rt[i-1],1,n,rk[i]);
	for(int i=1;i<=20;++i)
	  for(int j=1;j<=n;++j)
	    f[i][j]=min(f[i-1][j],f[i-1][min(n,j+(1<<(i-1)))]);
}
bool look(int L,int x)
{
	fl=0;
	int __L=x-L+1,_L,_R,ans=rk[L],l=rk[L],r=n;
	while(l<=r)
	{
		if(GET_LCP(rk[L],mid)>=__L) ans=mid,l=mid+1;
		else r=mid-1;
	}
	_R=ans,l=1,r=ans=rk[L];
	while(l<=r)
	{
		if(GET_LCP(mid,rk[L])>=__L) ans=mid,r=mid-1;
		else l=mid+1;
	}
	_L=ans;
	return ask(1,n,rt[x-__L],_L,_R);
}
int main()
{
	n=read();
	for(int i=1;i<=n;++i)
	  A[i]=(q){a[i]=read(),i};
	sort(A+1,A+1+n);
	for(int i=1;i<=n;++i)
	  {
	  	if(A[i].x!=A[i-1].x) ++id;
	  	a[A[i].id]=id;
	  }
	Suffix(),Init();
	for(int i=1,l,r,Ans;i<=n;++i)
	  {
	  	l=1,r=i,Ans=i;
	  	while(l<=r)
	  	{
	  		if(look(mid,i)) Ans=mid,r=mid-1;
	  		else l=mid+1;
		}
		ans+=Ans-look(Ans,i),printf("%lld\n",ans);
	  }
	return 0;
}
