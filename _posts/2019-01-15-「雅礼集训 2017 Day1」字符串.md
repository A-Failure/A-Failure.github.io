---
layout:		post
title:		"「雅礼集训 2017 Day1」字符串"
date:		2019-01-15
author:		"Dispwnl"
header-img:	"img/used/38533.jpg"
catalog:	false
tags:
    - 后缀自动机
    - 莫队
    - 倍增

---

## [题目](https://loj.ac/problem/6031)

### 题目描述

令 $s$ 与 $w$ 为两字符串，定义：

1. $w[l, r]$ 表示字符串 $w$ 在区间 $[l, r]$ 中的子串；
2. $w$ 在 $s$ 中出现的频率定义为$w$ 在 $s$ 中出现的次数；
3. $f(s, w, l, r)$ 表示 $w[l, r]$ 在 $s$ 中出现的频率。

比如 $f(\texttt{ababa}, \texttt{aba}, 1, 3) = 2$。

现在给定串 $s$，$m$ 个区间 $[l, r]$ 和长度 $k$，你要回答 $q$ 个询问，每个询问给你一个长度为 $k$ 的字符串 $w$ 和两个整数 $a, b$，求：$\sum\limits_{i = a} ^ b f(s, w, l_i, r_i)$


### 输入格式

第一行四个整数 $n, m, q, k$，$n$ 表示 $s$ 的长度。
接下来一行一个长为 $s$ 的字符串 $s$。
接下来 $m$ 行，每行两个整数表示 $l_i, r_i$。
接下来 $q$ 行，每行一个字符串 $w$，两个整数 $a, b$。

### 输出格式

对于每个询问一行，输出答案。

### 样例

#### 样例输入

```plain
8 5 3 3
abacdaba
0 2
1 2
0 0
2 2
1 2
dab 1 4
bac 2 3
eeb 1 3
```

#### 样例输出

```plain
7
3
2
```

### 数据范围与提示

对于 $10\%​$ 的数据，$n, m, k, q \leq 10​$；
对于 $30\%​$ 的数据，满足 $n, m, k, q \leq 10 ^ 2​$；
对于 $50\%​$ 的数据，满足 $n, m, k, q \leq 10 ^ 4​$；
对于 $100\%​$ 的数据，满足 $n, m, k, q \leq 10 ^ 5, \sum w \leq 10 ^ 5​$，字符串由小写英文字母构成。

### 题解

真·数据分治

发现$\sum w_i=k\times q\le 10^5$，所以分$k$的大小讨论

如果$k​$比较小，小到可以支持$O(k^2)​$的复杂度，那么可以维护$w​$上的区间$[a,b]​$在询问$[l,r]​$中出现的次数$t​$，这样就可以枚举$w​$的每一段子串，匹配到状态$A​$的时候，这段子串答案就是$t\times right_A​$，求和即可，复杂度$O(n(\sqrt n +k^2))​$

如果$k$比较大，说明$q$比较小，匹配字符串的时候如果这个位置是某个询问的右端点，所以ta的祖先中最小的大于等于询问区间长度的$len$对应的状态的$right$集合大小就是这个询问的答案，这个可以倍增处理，复杂度$O(q\times (\log k+k))$

~~为什么不能分成两道题出呢……~~

### 代码

```c++
# include<iostream>
# include<cstring>
# include<cstdio>
# include<vector>
# include<cmath>
# include<algorithm>
# define LL long long
using namespace std;
const int MAX=2e5+5,N=505;
int n,m,Q,K,k;
int pos[MAX],_l[MAX];
LL ans[MAX];
struct p{
	int l,r,id;
	bool operator< (const p &a)
	const{
		if(pos[l]!=pos[a.l]) return pos[l]<pos[a.l];
		return r<a.r;
	}
}qu[MAX];
struct q{
	int l,r;
}_qu[MAX];
struct o{
	int l,id;
};
int Ans[N][N];
char a[MAX],A[MAX];
vector<o> vec[MAX];
struct SAM{
	int l,r,L;
	int len[MAX],fa[MAX],siz[MAX],id[MAX],tax[MAX];
	int son[MAX][26],f[19][MAX];
	SAM() {l=r=1;}
	void ins(int x)
	{
		int tt=r;
		len[r=++l]=++L,siz[r]=1;
		for(;tt&&!son[tt][x];tt=fa[tt])
		  son[tt][x]=r;
		if(!tt) return void(fa[r]=1);
		int qwq=son[tt][x];
		if(len[qwq]==len[tt]+1) return void(fa[r]=qwq);
		len[++l]=len[tt]+1,fa[l]=fa[qwq],fa[qwq]=fa[r]=l;
		for(int i=0;i<26;++i)
		  son[l][i]=son[qwq][i];
		for(int i=tt;son[i][x]==qwq;i=fa[i])
		  son[i][x]=l;
	}
	void Init()
	{
		for(int i=1;i<=l;++i)
		  ++tax[len[i]];
		for(int i=1;i<=n;++i)
		  tax[i]+=tax[i-1];
		for(int i=l;i>=1;--i)
		  id[tax[len[i]]--]=i;
		for(int i=l;i>=1;--i)
		  siz[fa[id[i]]]+=siz[id[i]];
	}
	void Init_()
	{
		for(int i=2;i<=l;++i)
		  f[0][i]=fa[i];
		for(int i=1;i<=18;++i)
		  for(int j=1;j<=l;++j)
		    f[i][j]=f[i-1][f[i-1][j]];
	}
	LL GET_ANS(int _L,int id)
	{
		LL ans=0;
		for(int i=_L;i<_L+K;++i)
		  for(int j=i,x=1;j<_L+K;++j)
		    {
		    	x=son[x][A[j]-'a'];
		    	if(!x) continue;
		    	ans+=1ll*Ans[i-id*K][j-id*K]*siz[x];
			}
		return ans;
	}
	LL GET_ANS_(int l,int r)
	{
		LL ans=0;
		for(int i=1,x=1,_L=0;i<=K;++i)
		  {
		  	if(son[x][a[i]-'a']) x=son[x][a[i]-'a'],++_L;
		  	else
		  	{
		  		while(x&&!son[x][a[i]-'a']) x=fa[x];
		  		if(!x) x=1,_L=0;
		  		else _L=len[x]+1,x=son[x][a[i]-'a'];
			}
			for(int j=0,cnt=vec[i].size();j<cnt;++j)
			  {
			  	o tt=vec[i][j];
			  	if(tt.id>=l&&tt.id<=r&&_L>=i-tt.l+1)
			  	{
			  		int _x=x;
			  		for(int k=18;k>=0;--k)
			  		  if(len[f[k][_x]]>=i-tt.l+1) _x=f[k][_x];
			  		ans+=siz[_x];
				}
			  }
		  }
		return ans;
	}
}_S;
int read()
{
	int x(0);
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar());
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x;
}
void del(int x) {--Ans[_qu[x].l][_qu[x].r];}
void add(int x) {++Ans[_qu[x].l][_qu[x].r];}
void Solve()
{
	for(int i=1;i<=m;++i)
	  _qu[i].l=read()+1,_qu[i].r=read()+1;
	k=sqrt(m);
	if(m%k) ++k;
	for(int i=1;i<=m;++i)
	  pos[i]=(i-1)/k+1;
	for(int i=1,len=0;i<=Q;++i)
	  {
	  	char ch=getchar();
	  	for(;!isalpha(ch);ch=getchar());
	  	_l[i]=len+1;
	  	for(;isalpha(ch);A[++len]=ch,ch=getchar());
	  	qu[i].l=read()+1,qu[i].r=read()+1,qu[i].id=i;
	  }
	sort(qu+1,qu+1+Q);
	for(int i=1,l=1,r=0;i<=Q;++i)
	  {
	  	while(l<qu[i].l) del(l++);
	  	while(r<qu[i].r) add(++r);
	  	while(l>qu[i].l) add(--l);
	  	while(r>qu[i].r) del(r--);
	  	ans[qu[i].id]=_S.GET_ANS(_l[qu[i].id],qu[i].id-1);
	  }
	for(int i=1;i<=Q;++i)
	  printf("%lld\n",ans[i]);
}
void Solve_()
{
	for(int i=1,l;i<=m;++i)
	  l=read()+1,vec[read()+1].push_back((o){l,i});
	_S.Init_();
	for(int i=1,l;i<=Q;++i)
	  scanf("%s",a+1),l=read()+1,printf("%lld\n",_S.GET_ANS_(l,read()+1));
}
int main()
{
	n=read(),m=read(),Q=read(),K=read(),scanf("%s",a+1);
	for(int i=1;i<=n;++i)
	  _S.ins(a[i]-'a');
	return _S.Init(),K<N?Solve():Solve_(),0;
}
```



