---
layout:         post
title:          "LOJ刷题记录"
date:           2018-10-24
author:         "Dispwnl"
catalog:        true
tags:
    - 动态规划
---
最近做了一些LOJ的动态规划的题……

## 区间类动态规划
### 「一本通 5.1 例 1」石子合并
#### 题解
简单的区间$dp$

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=405;
int n;
int a[MAX],sum[MAX];
int f[MAX][MAX],g[MAX][MAX];
int main()
{
	scanf("%d",&n);
	memset(g,1,sizeof(g));
	for(int i=1;i<=n;++i)
	  scanf("%d",&a[i]),a[i+n]=a[i];
	for(int i=1;i<=n*2;++i)
	  f[i][i]=g[i][i]=0,sum[i]=sum[i-1]+a[i];
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=2*n-i;++j)
	    for(int k=j;k<j+i;++k)
	      f[j][j+i]=max(f[j][j+i],f[j][k]+f[k+1][j+i]+sum[j+i]-sum[j-1]),g[j][j+i]=min(g[j][j+i],g[j][k]+g[k+1][j+i]+sum[j+i]-sum[j-1]);
	int maxn=0,minn=1e9;
	for(int i=1;i<=n;++i)
	  maxn=max(maxn,f[i][i+n-1]),minn=min(minn,g[i][i+n-1]);
	return printf("%d\n%d",minn,maxn),0;
}
```
### 「一本通 5.1 例 2」能量项链
#### 题解
简单的区间$dp$

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=305;
int n;
int a[MAX],b[MAX];
int f[MAX][MAX];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	  scanf("%d",&a[i]),a[i+n]=a[i];
	for(int i=1;i<2*n;++i)
	  b[i]=a[i+1];
	b[2*n]=a[1];
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=2*n-i;++j)
	    for(int k=j;k<j+i;++k)
	      f[j][j+i]=max(f[j][j+i],f[j][k]+f[k+1][j+i]+a[j]*b[k]*b[j+i]);
	int maxn=0;
	for(int i=1;i<=n;++i)
	  maxn=max(maxn,f[i][i+n-1]);
	return printf("%d",maxn),0;
}
```
### 「一本通 5.1 例 3」凸多边形的划分
#### 题解
看成最大值WA了一发……

竟然要用高精度又WA了两发……

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
# define LL long long
using namespace std;
const int MAX=205;
const string inf="99999999999999999999999999999999999999";
int n;
int a[MAX],b[MAX],c[MAX];
string d[MAX];
string f[MAX][MAX];
string operator* (string A,string B)
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	string ans="";
	int L1=A.length(),L2=B.length(),L3=L1+L2,x=0;
	for(int i=1;i<=L1;++i)
	  b[i]=A[L1-i]-'0';
	for(int i=1;i<=L2;++i)
	  c[i]=B[L2-i]-'0';
	for(int i=1;i<=L1;++i)
	  {
	  	for(int j=1;j<=L2;++j)
	  	  a[i+j-1]+=b[i]*c[j]+x,x=a[i+j-1]/10,a[i+j-1]%=10;
	  	a[i+L2]=x,x=0;
	  }
	while(!a[L3]&&L3>1) --L3;
	for(int i=L3;i>=1;--i)
	  ans+=a[i]+'0';
	return ans;
}
string operator+ (string A,string B)
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	string ans="";
	int L1=A.length(),L2=B.length(),L3=max(L1,L2),x=0;
	for(int i=1;i<=L1;++i)
	  b[i]=A[L1-i]-'0';
	for(int i=1;i<=L2;++i)
	  c[i]=B[L2-i]-'0';
	for(int i=1;i<=L3;++i)
	  a[i]=b[i]+c[i]+x,x=a[i]/10,a[i]%=10;
	if(x) a[++L3]=x;
	for(int i=L3;i>=1;--i)
	  ans+=a[i]+'0';
	return ans;
}
string min(string A,string B)
{
	int L1=A.length(),L2=B.length();
	if(L1>L2) return B;
	if(L1<L2) return A;
	for(int i=0;i<L1;++i)
	  if(A[i]>B[i]) return B;
	  else if(A[i]<B[i]) return A;
	return A;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	  cin>>d[i],d[i+n]=d[i];
	for(int i=1;i<=2*n;++i)
	  for(int j=1;j<=2*n;++j)
	    f[i][j]=inf;
	for(int i=1;i<=2*n;++i)
	  f[i][i+1]=f[i][i]="0";
	for(int i=2;i<n;++i)
	  for(int j=1;j<=2*n-i;++j)
	    for(int k=j+1;k<j+i;++k)
	      f[j][j+i]=min(f[j][j+i],f[j][k]+f[k][j+i]+(d[j]*d[k]*d[j+i]));
	string minn=inf;
	for(int i=1;i<=n;++i)
	  minn=min(minn,f[i][i+n-1]);
	return cout<<minn,0;
}
```
### 「一本通 5.1 练习 1」括号配对
#### 题解
前两天刚做过一道类似的……

双个的不匹配就$+2$，一个的就$+1$

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=205;
int n;
char s[MAX];
int f[MAX][MAX];
int work(int x,int y)
{
	if(s[x]=='['&&s[y]==']') return 0;
	if(s[x]=='('&&s[y]==')') return 0;
	return 2;
}
int main()
{
	scanf("%s",s+1),n=strlen(s+1);
	for(int i=1;i<=n;++i)
	  {
	  	f[i][i]=1;
	  	for(int j=i+1;j<=n;++j)
	      f[i][j]=1e9;
	  }
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=n-i;++j)
	    {
	    	f[j][j+i]=f[j+1][j+i-1]+work(j,j+i);
	    	for(int k=j;k<j+i;++k)
	    	  f[j][j+i]=min(f[j][j+i],f[j][k]+f[k+1][j+i]);
		}
	return printf("%d",f[1][n]),0;
}
```
### 「一本通 5.1 练习 2」分离与合体
#### 题解
一样的套路

递归输出方案即可

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<queue>
# include<algorithm>
using namespace std;
const int MAX=305;
struct p{
	int l,r;
};
int n;
int a[MAX];
int f[MAX][MAX];
void coutt()
{
	queue<p> qu;
	qu.push((p){1,n});
	while(!qu.empty())
	{
		p tt=qu.front();
		qu.pop();
		for(int i=tt.l;i<tt.r;++i)
		  if(f[tt.l][i]+f[i+1][tt.r]+(a[tt.l]+a[tt.r])*a[i]==f[tt.l][tt.r])
		  {
		  	qu.push((p){tt.l,i}),qu.push((p){i+1,tt.r}),printf("%d ",i);
		  	break;
		  }
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	  scanf("%d",&a[i]);
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=n-i;++j)
	    for(int k=j;k<j+i;++k)
	      f[j][j+i]=max(f[j][j+i],f[j][k]+f[k+1][j+i]+(a[j]+a[j+i])*a[k]);
	return printf("%d\n",f[1][n]),coutt(),0;
}
```
### 「一本通 5.1 练习 3」矩阵取数游戏
#### 题解
一行一行的处理即可

依然得用高精度

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=105;
int n,m;
int a[MAX],b[MAX],c[MAX]; 
string mi_2[MAX];
string A[MAX][MAX],f[MAX][MAX];
string operator* (string A,string B)
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	string ans="";
	int L1=A.length(),L2=B.length(),L3=L1+L2,x=0;
	for(int i=1;i<=L1;++i)
	  b[i]=A[L1-i]-'0';
	for(int i=1;i<=L2;++i)
	  c[i]=B[L2-i]-'0';
	for(int i=1;i<=L1;++i)
	  {
	  	for(int j=1;j<=L2;++j)
	  	  a[i+j-1]+=b[i]*c[j]+x,x=a[i+j-1]/10,a[i+j-1]%=10;
	  	a[i+L2]=x,x=0;
	  }
	while(!a[L3]&&L3>1) --L3;
	for(int i=L3;i>=1;--i)
	  ans+=a[i]+'0';
	return ans;
}
string operator+ (string A,string B)
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(c,0,sizeof(c));
	string ans="";
	int L1=A.length(),L2=B.length(),L3=max(L1,L2),x=0;
	for(int i=1;i<=L1;++i)
	  b[i]=A[L1-i]-'0';
	for(int i=1;i<=L2;++i)
	  c[i]=B[L2-i]-'0';
	for(int i=1;i<=L3;++i)
	  a[i]=b[i]+c[i]+x,x=a[i]/10,a[i]%=10;
	if(x) a[++L3]=x;
	for(int i=L3;i>=1;--i)
	  ans+=a[i]+'0';
	return ans;
}
string max(string A,string B)
{
	int L1=A.length(),L2=B.length();
	if(L1<L2) return B;
	if(L1>L2) return A;
	for(int i=0;i<L1;++i)
	  if(A[i]<B[i]) return B;
	  else if(A[i]>B[i]) return A;
	return A;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=m;++j)
	    cin>>A[i][j];
	mi_2[0]="1";
	for(int i=1;i<=m;++i)
	  mi_2[i]=mi_2[i-1]*"2";
	string ans="0";
	for(int i=1;i<=n;++i)
	  {
	  	for(int j=1;j<=m;++j)
	  	  for(int k=1;k<=m;++k)
	  	    f[j][k]="0";
	  	for(int j=m;j>=1;--j)
	  	  for(int l=1;l<=j;++l)
	  	    f[l][m-j+l]=max(f[l][m-j+l],f[l+1][m-j+l]+mi_2[j]*A[i][l]),f[j-l+1][m-l+1]=max(f[j-l+1][m-l+1],f[j-l+1][m-l]+mi_2[j]*A[i][m-l+1]);
	  	ans=ans+f[1][m];
	  }
	return cout<<ans,0;
}
```
## 树型动态规划
### 「一本通 5.2 例 1」二叉苹果树
#### 题解
必须保留根节点

简单的树上背包

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=1e3+5;
struct p{
	int x,y,dis;
}c[MAX];
int n,m,num;
int h[MAX],d[MAX],fa[MAX],w[MAX];
int f[MAX][MAX];
void add(int x=0,int y=0,int dis=0)
{
	scanf("%d%d%d",&x,&y,&dis);
	c[++num]=(p){h[x],y,dis},h[x]=num;
	c[++num]=(p){h[y],x,dis},h[y]=num;
}
void dfs(int x=1,int f=0)
{
	d[x]=d[f]+1,fa[x]=f;
	for(int i=h[x];i;i=c[i].x)
	  if(c[i].y!=f) w[c[i].y]=c[i].dis,dfs(c[i].y,x);
}
void Dfs(int x=1)
{
	for(int i=h[x];i;i=c[i].x)
	  if(c[i].y!=fa[x]) Dfs(c[i].y);
	for(int i=h[x];i;i=c[i].x)
	  if(c[i].y!=fa[x]) for(int j=m-(x!=1);j>=0;--j)
	    for(int k=0;k<=j;++k)
	      f[x][j]=max(f[x][j],f[x][j-k]+f[c[i].y][k]);
	if(x!=1) for(int i=m;i>=1;--i)
	  f[x][i]=f[x][i-1]+w[x];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;++i,add());
	dfs(),Dfs();
	return printf("%d",f[1][m]),0;
}
```
### 「一本通 5.2 例 2」选课
#### 题解
一样的树上背包

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=1e3+5;
struct p{
	int x,y;
}c[MAX];
int n,m,num;
int w[MAX],h[MAX];
int f[MAX][MAX];
void add(int x,int y)
{
	c[++num]=(p){h[x],y},h[x]=num;
}
void dfs(int x=0)
{
	for(int i=h[x];i;i=c[i].x)
	  {
	  	dfs(c[i].y);
	  	for(int j=m-bool(x);j>=0;--j)
	  	  for(int k=0;k<=j;++k)
	  	    f[x][j]=max(f[x][j],f[x][j-k]+f[c[i].y][k]);
	  }
	if(x) for(int i=m;i>=1;--i)
	  f[x][i]=f[x][i-1]+w[x];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1,x;i<=n;++i)
	  scanf("%d%d",&x,&w[i]),add(x,i);
	dfs();
	return printf("%d",f[0][m]),0;
}
```
### 「一本通 5.2 例 3」数字转换
#### 题解
处理出来关系发现是一棵树

求树上直径即可~~为什么要用树形dp求直径啊~~

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<cmath>
# include<algorithm>
using namespace std;
const int MAX=5e4+5;
struct p{
	int x,y;
}c[MAX<<1];
int n,m,num,maxn,id;
int h[MAX],d[MAX];
void add(int x,int y)
{
	c[++num]=(p){h[x],y},h[x]=num;
	c[++num]=(p){h[y],x},h[y]=num;
}
void ss()
{
	for(int i=1,sum;i<=n;++i)
	  {
	  	sum=0;
	  	for(int j=1;j<=sqrt(i);++j)
	  	  if(i%j==0)
	  	  {
	  	  	sum+=j;
	  	  	if(j!=i/j&&i/j!=i) sum+=i/j;
	  	  	if(sum>=i) break;
		  }
		if(sum<i) add(i,sum);
	  }
}
void dfs(int x,int fa=0)
{
	d[x]=d[fa]+1;
	if(d[x]>maxn) maxn=d[x],id=x;
	for(int i=h[x];i;i=c[i].x)
	  if(c[i].y!=fa) dfs(c[i].y,x);
}
void work()
{
	maxn=0,id;
	dfs(1),maxn=0,dfs(id),maxn=0,dfs(id);
	printf("%d",maxn-1);
}
int main()
{
	scanf("%d",&n);
	return ss(),work(),0;
}
```
### 「一本通 5.2 例 4」战略游戏
#### 题解
$f_{0/1,i}$表示$i$选不选的最少士兵数

因为点权都一样，转移就比较简单了

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=4e3+5;
struct p{
	int x,y;
}c[MAX];
int n,num;
int h[MAX];
int f[2][MAX];
void add(int x,int y)
{
	c[++num]=(p){h[x],y},h[x]=num;
	c[++num]=(p){h[y],x},h[y]=num;
}
void dfs(int x=0,int fa=0)
{
	f[1][x]=1,f[0][x]=0;
	int sum=0,minn=1e9;
	for(int i=h[x];i;i=c[i].x)
	  if(c[i].y!=fa) dfs(c[i].y,x),f[1][x]+=min(f[0][c[i].y],f[1][c[i].y]),f[0][x]+=f[1][c[i].y];
}
int main()
{
	scanf("%d",&n);
	memset(f,1,sizeof(f));
	for(int i=1,id,k,x;i<=n;++i)
	  {
	  	scanf("%d%d",&id,&k);
	  	for(int j=1;j<=k;++j)
	  	  scanf("%d",&x),add(id,x);
	  }
	return dfs(),printf("%d",min(f[0][0],f[1][0])),0;
}
```
### 「一本通 5.2 例 5」皇宫看守
#### 题解
这题跟上一题差不多，但是点权不相等了

$f_{0/1,0/1,i}$表示$i$选不选、$i$的父亲选不选的最小代价

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=4e3+5;
struct p{
	int x,y;
}c[MAX];
int n,num;
int h[MAX],w[MAX];
int f[2][2][MAX];
void add(int x,int y)
{
	c[++num]=(p){h[x],y},h[x]=num;
	c[++num]=(p){h[y],x},h[y]=num;
}
void dfs(int x=1,int fa=0)
{
	f[1][1][x]=f[1][0][x]=w[x],f[0][1][x]=f[0][0][x]=0;
	int sum=0,minn=1e9,cnt=0,cnt1=0;
	for(int i=h[x];i;i=c[i].x)
	  if(c[i].y!=fa) dfs(c[i].y,x),f[1][1][x]=f[1][0][x]+=min(f[1][1][c[i].y],f[0][1][c[i].y]),f[0][1][x]+=min(f[1][0][c[i].y],f[0][0][c[i].y]),sum+=f[1][0][c[i].y];
	for(int i=h[x];i;i=c[i].x)
	  if(c[i].y!=fa)
	  {
	  	++cnt;
	  	if(f[1][0][c[i].y]>f[0][0][c[i].y]) sum+=f[0][0][c[i].y]-f[1][0][c[i].y],++cnt1;
	  }
	if(cnt==cnt1)
	{
		for(int i=h[x];i;i=c[i].x)
		  if(c[i].y!=fa) minn=min(minn,sum-f[0][0][c[i].y]+f[1][0][c[i].y]);
	}
	else minn=sum;
	f[0][0][x]=minn;
}
int main()
{
	scanf("%d",&n);
	memset(f,1,sizeof(f));
	for(int i=1,id,k,m,x;i<=n;++i)
	  {
	  	scanf("%d%d%d",&id,&k,&m),w[id]=k;
	  	for(int j=1;j<=m;++j)
	  	  scanf("%d",&x),add(id,x);
	  }
	return dfs(),printf("%d",min(f[0][0][1],min(f[1][1][1],f[1][0][1]))),0;
}
```
### 「一本通 5.2 练习 1」加分二叉树
#### 题解
树形$dp$？区间$dp$？
![](/img/？？？？？.jpg)

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
# define LL long long
using namespace std;
const int MAX=105;
int n;
int a[MAX];
LL f[MAX][MAX];
void coutt(int l,int r)
{
	int rt=0;
	if(l>r) return;
	if(l==r) return void(printf("%d ",l));
	for(int i=l;i<=r;++i)
	  if(f[l][i-1]*f[i+1][r]+a[i]==f[l][r]) {rt=i;break;}
	printf("%d ",rt),coutt(l,rt-1),coutt(rt+1,r);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	  scanf("%d",&a[i]);
	for(int i=1;i<=n;++i)
	  {
	  	for(int j=0;j<=n;++j)
	      f[i][j]=1;
	    f[i][i]=a[i];
	  }
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=n-i;++j)
	    for(int k=j;k<=j+i;++k)
	      f[j][j+i]=max(f[j][j+i],f[j][k-1]*f[k+1][j+i]+a[k]);
	return printf("%lld\n",f[1][n]),coutt(1,n),0;
}
```
### 「一本通 5.2 练习 2」旅游规划
#### 题解
没想出树形$dp$……

用点分治的统计方法强行艹过去了qaq ~~好难调~~

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=4e5+5;
struct p{
	int x,y;
}c[MAX];
struct q{
	int x,y,id;
	bool operator< (const q &a)
	const{
		return x<a.x;
	}
}D[MAX];
int n,num,cnt,maxn,id,col,qaq;
int ans[MAX],d[MAX],h[MAX],fa[MAX],bom[MAX];
int use[MAX];
void add(int x=0,int y=0)
{
	scanf("%d%d",&x,&y),++x,++y;
	c[++num]=(p){h[x],y},h[x]=num;
	c[++num]=(p){h[y],x},h[y]=num;
}
void dfs(int x,int f=0)
{
	d[x]=d[f]+1,fa[x]=f;
	if(maxn<d[x]) maxn=d[x],id=x;
	for(int i=h[x];i;i=c[i].x)
	  if(c[i].y!=f) dfs(c[i].y,x);
}
void GET_NUM(int x,int f,int d,int Col)
{
    D[++qaq]=(q){d+1,Col,x},fa[x]=f;
	for(int i=h[x];i;i=c[i].x)
      if(c[i].y!=f) GET_NUM(c[i].y,x,d+1,D[qaq].y);
}
int look(int l,int x)
{
    int ans=0,r=qaq;
    while(l<=r)
    {
        int mid(l+r>>1);
        if(D[mid].x<x) l=mid+1;
        else ans=mid,r=mid-1;
    }
    return ans;
}
void GET_ANS(int id)
{
	while(id&&!use[id]) use[id]=1,ans[++cnt]=id,id=fa[id];
}
void work()
{
	dfs(1),maxn=0,dfs(id),maxn=0;
	int s1=id,s2;
	dfs(id),s2=id,GET_ANS(s2),--maxn;
	for(int i=cnt;i>=1;--i)
	  {
	  	col=0,qaq=0;
		for(int j=h[ans[i]];j;j=c[j].x)
		  if(!use[c[j].y]) GET_NUM(c[j].y,ans[i],0,++col),fa[c[j].y]=0;
		D[++qaq]=(q){i-1,0,s2},D[++qaq]=(q){maxn-i+1,0,s1},sort(D+1,D+1+qaq);
	    int l=1;
	   	while(D[l].x+D[qaq].x<maxn&&l<qaq) ++l;
	    while(l<qaq&&maxn-D[l].x>=D[l].x)
	    {
	        int D3,D1(look(l+1,maxn-D[l].x));
  	    	D3=D1; 
        	for(;D[D3].x==maxn-D[l].x;++D3)
        	  if(D[l].y!=D[D3].y)
        	  {
        	  	if(!use[D[l].id]) GET_ANS(D[l].id);
				if(!use[D[D3].id]) GET_ANS(D[D3].id);
			  }
        	++l;
    	}
	  }
	sort(ans+1,ans+1+cnt);
	for(int i=1;i<=cnt;++i)
	  printf("%d\n",ans[i]-1);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;++i,add());
	return work(),0;
}
```
### 「一本通 5.2 练习 3」周年纪念晚会
#### 题解
没有上司的舞会？

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=2e4+5;
struct p{
	int x,y;
}c[MAX];
int n,num,rt;
int h[MAX],w[MAX],du[MAX];
int f[2][MAX];
void add(int x=0,int y=0)
{
	scanf("%d%d",&y,&x),++du[y];
	c[++num]=(p){h[x],y},h[x]=num;
}
void dfs(int x=rt)
{
	f[1][x]=w[x];
	for(int i=h[x];i;i=c[i].x)
	  dfs(c[i].y),f[0][x]+=max(f[0][c[i].y],f[1][c[i].y]),f[1][x]+=f[0][c[i].y];
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	  scanf("%d",&w[i]);
	for(int i=1;i<n;++i,add());
	for(int i=1;i<=n;++i)
	  if(!du[i]) {rt=i;break;}
	return dfs(),printf("%d",max(f[0][rt],f[1][rt])),0;
}
```
### 「一本通 5.2 练习 4」叶子的染色
#### 题解
从叶子开始求解，$f_{0/1,i}$表示$i$点染成$0$或$1$的最小代价

#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
using namespace std;
const int MAX=2e4+5;
struct p{
	int x,y;
}c[MAX];
int n,num,m,rt;
int du[MAX],w[MAX],h[MAX];
int f[2][MAX];
void add(int x=0,int y=0)
{
	scanf("%d%d",&x,&y),++du[x],++du[y];
	c[++num]=(p){h[x],y},h[x]=num;
	c[++num]=(p){h[y],x},h[y]=num;
}
void dfs(int x=rt,int fa=0)
{
	if(w[x]!=-1) f[w[x]][x]=1;
	else f[0][x]=f[1][x]=1;
	for(int i=h[x];i;i=c[i].x)
	  if(c[i].y!=fa) dfs(c[i].y,x),f[1][x]+=min(f[1][c[i].y]-1,f[0][c[i].y]),f[0][x]+=min(f[0][c[i].y]-1,f[1][c[i].y]);
}
int main()
{
	scanf("%d%d",&n,&m);
	memset(w,-1,sizeof(w));
	memset(f,1,sizeof(f));
	for(int i=1;i<=m;++i)
	  scanf("%d",&w[i]);
	for(int i=1;i<n;++i,add());
	for(int i=1;i<=n;++i)
	  if(du[i]>1) {rt=i;break;}
	return dfs(),printf("%d",min(f[1][rt],f[0][rt])),0;
}
```
### 「一本通 5.2 练习 5」骑士
#### 题解
图是多棵基环树，每个基环树单独处理

去掉环的一条边，然后树形$dp$求解
#### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
# define LL long long
using namespace std;
const int MAX=1e6+5;
struct p{
	int x,y;
}c[MAX];
int n,num,s1,s2;
int h[MAX],w[MAX],fa[MAX];
LL f[2][MAX];
bool use[MAX];
void add(int x,int y)
{
	fa[y]=x,c[++num]=(p){h[x],y},h[x]=num;
}
void dfs(int x)
{
	f[1][x]=w[x],f[0][x]=0,use[x]=1;
	for(int i=h[x];i;i=c[i].x)
	  if(x!=s2||c[i].y!=s1) dfs(c[i].y),f[0][x]+=max(f[0][c[i].y],f[1][c[i].y]),f[1][x]+=f[0][c[i].y];
}
LL GET_ANS(int x)
{
	int s=x;
	while(fa[x]&&!use[x]) use[x]=1,s1=x,s2=x=fa[x];
	dfs(s1);
	if(!s2) return max(f[0][s1],f[1][s1]);
	LL tt=f[0][s1],qwq=w[s2];
	w[s2]=0,dfs(s1),w[s2]=qwq;
	return max(tt,f[1][s1]);
}
int main()
{
	scanf("%d",&n);
	for(int i=1,x;i<=n;++i)
	  scanf("%d%d",&w[i],&x),add(x,i);
	LL ans=0;
	for(int i=1;i<=n;++i)
	  if(!use[i]) ans+=GET_ANS(i);
	return printf("%lld",ans),0;
}
```
